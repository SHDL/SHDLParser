/*
* Usage : bla bla
* Bla bla
*
*/
module alarm(rst, clk, en, delay[7..0] : alarm)
   // 8-bit counter
   count8Z(rst, clk, en, idle : cnt[7..0], _)
   // compare counter value 'cnt' with 'delay'
   eq8(cnt[7..0], delay[7..0] : equal)
   // finite state machine acting on 'en' and 'equal', producing 'alarm'
   // (fsm states can be used as signals in their container module, the active state being '1' and all others '0')
   fsm synchronous on clk, idle while rst
      * -> idle when /en,
      idle, busy -> busy when en*/equal,
      busy -> alarm when en*equal,
      alarm -> alarm when en,
      alarm -> idle when /en
   end fsm
   
end module


module flipflopT(rst, clk, en, t : on, off)
   fsm off while rst, synchronous on clk
      off -> off when /t + /en,
      on -> on when /t + /en,
      off -> on when t * en,
      on -> off when t * en
   end fsm
end module


module count2Z(rst, clk, en, sclr : q[1..0], allone)
   flipflopT(rst, clk, en, t[0] : q[0], _)
   flipflopT(rst, clk, en, t[1] : q[1], _)
   t[0] = /sclr + q[0]
   t[1] = /sclr*q[0] + q[1]
   allone = q[0] * q[1]
end module

module count4Z(rst, clk, en, sclr : q[3..0], allone)
   count2Z(rst, clk, en, sclr : q[1..0], alloneL)
   enH = en*alloneL + en*sclr
   count2Z(rst, clk, enH, sclr : q[3..2], alloneH)
   allone = alloneL * alloneH
end module

module count8Z(rst, clk, en, sclr : q[7..0], allone)
   count4Z(rst, clk, en, sclr : q[3..0], alloneL)
   enH = en*alloneL + en*sclr
   count4Z(rst, clk, enH, sclr : q[7..4], alloneH)
   allone = alloneL * alloneH
end module



